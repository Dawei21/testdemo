## 2021 年2月23日 阴天 微风 天冷

### 面试公司 -- 猿辅导


#### 一面：主要是基础知识及概念的理解
   
   
   Q1: 自我介绍 及遇到的项目难点及思考
   A1: 巴拉巴拉
   
   
   Q2：java虚拟机内存氛围几块
   A2: 
   
    线程共享：
        方法区：已被虚拟机加载的类型信息、常量、静态变量、即使编译器编译产生后的代码 【是堆的一个部分，是逻辑概念】
                **注意可以引出** ： 类加载过程
        堆： 运行中new来的对象实例及数组等
    线程私有：
        虚拟机栈： Java方法运行时产生的运行信息，主要以每个方法运行时产生的栈桢 主要存储，局部变量表、操作数栈、动态链接、方法出口，随着方法执行完会销毁
        本地方法栈：本地的native方法运行时的信息，内容同虚拟机栈
        程序计数器：记录程序执行位置 仅有此处不会产生oom
   
   Q3：jvm有那些垃圾回收算法
   A3：垃圾回收算法主要有三种：
    
        1、复制算法
            主要用于年轻代 从end+s1
        2、标记清除
            如何标记：
        3、标记整理
   
   Q4：垃圾回收如何标记哪些可以被回收
   A4：两种
        
        1、引用计数器
        2、可达性分析
            GC Roots：
                1、虚拟机栈（栈桢中的本地变量表）中引用的对象
                2、方法区中的静态属性引用的对象
                3、方法区中变量引用的对象
                4、本地方法栈中JNI(Native方法)引用的对象
                5、Java虚拟机内部的引用 基本数据类型的Class类型 常驻内存的一些对象，系统类加载器等
                6、所有被同步锁（synchronized）关键字持有的对象
                7、反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等
           
   Q5：计算机网络中的 ATM协议有了解么
   A5：不了解，没听过
   
        数据链路层的主要协议有：
        1、Point-to-Point Protocal —— PPP点到点。
        2、Ethernet —— 以太网。
        3、High-Level Data Link Control Protocal —— 高级链路控制协议。
        4、Frame Relay —— 帧中继。
        5、Asynchronous Transfer Mode —— 异步传输模式。   
        
   Q6：一个url链接在浏览器发送请求到响应过程中发生了那些事情
   A6：
        
        1、应用层的DNS域名解析协议 得到ip+端口
            查找浏览器缓存
            查找操作系统缓存
            查找路由器缓存
            ISP DNS缓存 （Internet service provider 因特网服务提供商）
            递归搜索 将域名分级缓存
           http https应用层协议  常基于TCP/IP协议传输数据
           http协议的版本变更过程：
               0.9 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求
               1.0 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令	
               1.1 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码
               2.0 多路复用、服务器推送、头信息压缩、二进制协议等	
           https: 经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包
           PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分    
                https有如下特点：
                    1、内容加密：采用混合加密技术，中间者无法直接查看明文内容
                    2、验证身份：通过证书认证客户端访问的是自己的服务器
                    3、保护数据完整性： 防止传输的内容被中间人冒充或者篡改
            
        2、将数据请求封装成请求包
        3、与服务器发生三次握手，建立链接
        4、传输数据
        5、与服务器进行四次回收，断开链接
      Q：https的请求又有哪些过程
          
   
   Q7: 讲一下mysql数据库索引
   A7：
        
        聚簇索引：叶子节点存储数据记录
        非聚簇索引：叶子节点存储主键索引的地址
    
   Q8: mysql事务有哪些隔离级别，解决了哪些问题
   A8：
        
        隔离级别：
            读未提交   
            读已提交    解决脏读   数据update delete       一致性非锁定读 对于加锁记录 使用当前读的方式每次请求都生成快照进行比对
            可重复读    解决不可重复读   数据update delete  一致性非锁定读 对于加锁记录使用快照读的方式读取，第一次请求产生的快照做比对；当数据修改时，将获取X锁，使用当前读进行数据获取
            序列化      解决幻读   长时间持有锁？
        mysql事务隔离级别的实现：
            读未提交：  
            读已提交：  当前读 快照读
            可重复读：  mvcc 及 锁
            序列化：通过使用间隙锁或临键锁  
   
   Q9：redis的数据结构有哪些，zset如何底层如何实现的
   A9：
        
        string list hash set zset
        
        zset
            ziplist 元素小于128 并且 所有成员的长度都小于64字节
            dict + skiplist
                字典和skip共享key和分值value
            跳表实现，跳表是在原有链表的基础上增加索引层，索引层通过level记录所以的数据及层高，并记录指向下一条数据的指针
        另外底层数据项会记录数据的前向 后向指针方便遍历
            zskiplistNode
                //后退指针
                struct zskiplist *backwark； 
                //分值
                double score;
                //成员对象
                robj *obj;
                //层
                struct zskiplistLevel {
                    //前进指针
                    struct zkipkistNode *forward;
                    //阔度
                    unsigned int span;
                } level[];
   Q10: redis 对于key失效有哪些处理
   A10:    
       
       服务一般采用 惰性删除 + 定期删除
       1、定时删除
            对内存友好，但是对cpu不友好
                对于需要删除的数据使用定时器，然而定时器有事一个时间事件-无序链表查找一个事件的事件复杂度是O(n) 需要创建大量的定时器
       2、惰性删除
            查询时删除
                使用FLUSHDB才会触发检查
       3、定期删除
           每隔一段时间执行一次删除过期键操作，并通过限制删除操作的执行时长和频率减少对cpu的占用
                通过activeExprieCycle函数实现 通过serverCron函数调用
           
       引申：一、redis的如何操作事务，为啥lua执行是原子的
            reids的事务多个命令集去执行，会因为别的客户端影响造成执行不成功
            lua脚本会将多个命令当成一个命令去执行，不会被别的脚本或者命令干扰，真正具有【原子性】
                redis提供简单的事务命命令 multi 和 exec 
                   可以理解为多个命令放在 multi和exec执行 multi作为事务的begin exec作为commit 而discard作为rollback watch相当于锁  
                   若对象在事务执行前被修改则事务被打断
                    因此redis的事务机制为乐观锁，高并发下多个客户端同时对一个key进行watch，只要有一个客户端提交了，其他客户端的操作都是无效的
                        watch某个key 在提交exec事务执行前，若其他任务执行操作修改了watch的key对应的值，此时exec提交将被回滚
                    为了处理高并发场景下的问题，可以使用lua脚本解决
                redis事务可以一次执行多个命令，并带有三个重要保证：
                    1、批量操作在发送EXEC命令前被放入队列缓存。
                    2、收到EXEC命令后进行事务执行，事务中任意命令执行失败，其余命令依然被执行。
                    3、在事务执行过程中，其他客户端提交的请求不会插入到事务执行命令序列中。
                事务执行的三个阶段：开始事务，命令入队，执行事务
                如果事务中出现错误：
                    1、还未exec就报错：整个事务回滚不会被执行
                    2、成功执行exec后报错：错的就错了不会执行，其他执行正常操作，不会触发回滚
            lua脚本的好处:
                1、lua脚本会被作为一个整体去执行，不会被其他命令插入
                2、可以将多条命令一次性打包，减少网络开销
                3、lua脚本可以常驻redis内存，可以执行拿来敷用，减少代码量 
            二、AOP重写
                1、主进程创建一个子进程进行redis数据库数据扫描，写入新创建的aop文件中
                2、创建子进程后会将客户端命令由原本的仅写入aop缓存池，增加写入到重写缓冲池
                3、当子进程将数据库中数据遍历重写完命令语句进新的aof文件中之后发送信号
                4、父进程接收到信号后将所有的重写缓冲取得文件都写入新的aof文件中，然后进行原子的改名操作，覆盖现有的aof文件，完成替换
                    信号处理会是对服务器进程【主进程】操作阻塞的               
   
   Q11: 线程安全的ArrayList有哪些
   A11:
        这真不记得了 Stack结构不对了啊
        
        Vector
         
   
   Q12: 算法：链表反转     
     [https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/][leetcode-反转链表]
     
     这个题我误区歧途 搞了更麻烦
   [leetcode-反转链表]: https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/

#### 二面：
    

   Q1：项目及工作经验介绍 项目中遇到的难点有哪些
   A1：巴拉巴拉
   
   Q2: dubbo服务拆分过程 Sentinel用他主要做了哪些事情，怎么抉择的
   A2：  
       
       如何推进服务拆分，及如何一步步替换老接口
       sentinel如何做的降级处理，哪些用了限流哪些做了降级 如何选择降级哪些内容
        
   
   Q3: jdk线程池参数介绍 线程数变换过程 如何留活
   A3：
        
        线程池基本参数：
            核心线程数、最大线程数、超时时间、时间单位、BlockingQueue、threadFactory、RejectHandler
        数量变化过程： 0 增长到核心线程数 在填充阻塞队列 再增加到最大线程数 再根据空闲时间摘除
        留活：
            getTask中有allowCoreThreadTimeOut参数和阻塞任务获取来决定是否回收
            
            timed ture 会使用带超时间的任务获取方式，到达时间没有获取到任务就将timeOut=true 下次循环将回收，否则阻塞等待取任务   
            timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();
        
   
   Q4：redis热点缓存如何保证可用性，以及缓存一致性如何实现
   A4：
        
        1、双rediskey
        2、本地缓存 追问 本地缓存数据如何更新
            两种策略都失效如何处理 ？
        
   
   Q5：kafka如何做消息消费的顺序性
   
   Q6: jvm线上问题解决及排查经验
   
   Q7: 算法：校验二叉树是否对称(不清楚是否是完全二叉树)
   A7:
        
        按层遍历 对比首尾
            时间复杂度多少 ？
   